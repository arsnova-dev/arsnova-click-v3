@startuml comm-student-client
' ============================================================================
' arsnova.click V3 â€“ Kommunikationsdiagramm: Student-Client â†” Backend
' Protokolle: HTTP (tRPC Queries/Mutations), WebSocket (tRPC Subscriptions)
' ============================================================================

!theme plain
skinparam shadowing false
skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true
skinparam maxMessageSize 220

title Student-Client â†” Backend â€“ Kommunikation\n(tRPC HTTP + WebSocket)

actor "ğŸ“± Student" as student
box "Browser (Angular)" #e3f2fd
  participant "VotingView\n(Signals)" as view
  participant "tRPC Client\n(httpBatchLink)" as http
  participant "tRPC Client\n(wsLink)" as ws
end box

box "Backend (Node.js)" #fff3e0
  participant "tRPC Router\n(Express)" as router
  participant "WebSocket\nServer" as wss
  participant "DTO Layer\nâš ï¸ Data-Strip" as dto
  participant "ScoringService" as scoring
end box

database "PostgreSQL" as pg
database "Redis" as redis

== Phase 1: Session beitreten ==

student -> view : Session-Code eingeben\n"A3F7K2"
view -> http : **session.getInfo()**\n//{ code: "A3F7K2" }//
http -> router : HTTP GET /trpc
router -> pg : Session finden\nWHERE code = 'A3F7K2'
router --> http : //SessionInfoDTO//\n{ id, code, type: "QUIZ",\nstatus: "LOBBY", quizName,\nparticipantCount: 5 }
view -> student : "Quiz: Mathe-Test\n5 Teilnehmer online"

alt Anonymer Modus (anonymousMode=true)
  view -> student : Automatisch:\n"Teilnehmer #6"
else Normaler Modus
  student -> view : Nickname wÃ¤hlen\n"Marie Curie"
end

view -> http : **session.join()**\n//JoinSessionInputSchema//\n{ code: "A3F7K2",\nnickname: "Marie Curie" }
http -> router : HTTP POST /trpc
router -> pg : Participant INSERT\n@@unique(sessionId, nickname)

alt Nickname bereits vergeben
  router --> http : TRPCError\nCONFLICT "Nickname belegt"
  view -> student : âŒ "Name bereits vergeben"
else Erfolg
  router -> redis : PUBLISH participantJoined
  router --> http : { participantId, token }
  view -> student : âœ… "Lobby beigetreten!"
end

view -> ws : **Subscribe:**\nsession.onQuestionRevealed\nsession.onResultsRevealed\nsession.onPersonalResult\nsession.onStatusChanged
ws -> wss : WebSocket CONNECT
note over ws, wss : Persistente WS-Verbindung\nfÃ¼r Echtzeit-Events

view -> student : Lobby-Ansicht:\n"Warten auf Dozentâ€¦"

== Phase 2: Frage empfangen ==

wss -> ws : **Event: onQuestionRevealed**
note over dto
  âš ï¸ **KRITISCH: Data-Stripping!**
  Server sendet **QuestionStudentDTO**:
  âœ… { id, text, type, timer, difficulty,
       answers: [{ id, text }] }
  âŒ Kein isCorrect!
  âŒ Kein voteCount!
end note

ws -> view : //QuestionStudentDTO//\n{ text: "Was ist âˆš144?",\ntype: "SINGLE_CHOICE",\ntimer: 30,\nanswers: [\n  { id: "a1", text: "10" },\n  { id: "a2", text: "12" },\n  { id: "a3", text: "14" },\n  { id: "a4", text: "16" }\n] }

view -> student : Frage + Buttons anzeigen\nâ–³ A: 10  â—‹ B: 12\nâ–¡ C: 14  â—‡ D: 16\nâ±ï¸ Countdown: 30s

== Phase 3a: Abstimmung â€“ Single Choice ==

student -> view : Button "â—‹ B: 12" antippen
note over view
  **Optimistisches UI-Update:**
  1. Button sofort als "gewÃ¤hlt" markieren âœ“
  2. Debounce 300ms (Doppel-Tap-Schutz)
  3. Spinner auf Button anzeigen
  4. Vibration API: navigator.vibrate(10)
end note

view -> http : **vote.submit()**\n//SubmitVoteInputSchema//\n{ sessionId, questionId,\nanswerIds: ["a2"],\nresponseTimeMs: 4200 }
http -> router : HTTP POST /trpc

router -> pg : Check: @@unique\n(session, participant, question)

alt Bereits abgestimmt
  router --> http : TRPCError\nCONFLICT "Bereits abgestimmt"
  view -> student : Rollback UI âŒ\n"Antwort konnte nicht\ngesendet werden"
else Rate-Limit Ã¼berschritten
  router --> http : TRPCError\nTOO_MANY_REQUESTS\nRetry-After: 1s
  view -> student : â³ "Bitte warte\nkurzâ€¦"
else Erfolg
  router -> pg : Vote INSERT\n+ VoteAnswer INSERT
  router -> scoring : Score berechnen
  scoring -> scoring : score = MEDIUM(Ã—2) Ã—\ntimeBonus(1000 Ã— (1 - 4.2/30))\n= 2 Ã— 860 = **1720**
  scoring -> scoring : Streak prÃ¼fen:\nstreakCount = 3 â†’ Ã—1.2\nfinalScore = 1720 Ã— 1.2 = **2064**
  scoring -> pg : Vote UPDATE\n(score, streakCount, streakBonus)
  router -> redis : PUBLISH voteReceived
  router --> http : { success: true }
  view -> student : âœ… "Antwort gesendet"\nSpinner â†’ HÃ¤kchen
end

== Phase 3b: Abstimmung â€“ Multiple Choice ==

wss -> ws : **Event: onQuestionRevealed**\n(MC-Frage)
ws -> view : //QuestionStudentDTO//\n{ type: "MULTIPLE_CHOICE", ... }
view -> student : MC-Buttons als Toggles:\nâ–³ A â˜  â—‹ B â˜  â–¡ C â˜  â—‡ D â˜

student -> view : "â–³ A" antippen â†’ â˜‘ï¸
student -> view : "â–¡ C" antippen â†’ â˜‘ï¸
student -> view : "Absenden" klicken

view -> http : **vote.submit()**\n{ answerIds: ["a1", "a3"],\nresponseTimeMs: 8500 }
http -> router : HTTP POST /trpc
router -> pg : Vote + 2Ã— VoteAnswer INSERT
router --> http : { success: true }

== Phase 3c: Abstimmung â€“ Freitext ==

wss -> ws : **Event: onQuestionRevealed**\n(FREETEXT-Frage)
ws -> view : //QuestionStudentDTO//\n{ type: "FREETEXT", ... }
view -> student : Textfeld anzeigen\n"Deine Antwortâ€¦"

student -> view : "Photosynthese" eingeben\n+ Absenden
view -> http : **vote.submit()**\n{ freeText: "Photosynthese" }
http -> router : HTTP POST /trpc
router --> http : { success: true }

== Phase 3d: Abstimmung â€“ Rating-Skala ==

wss -> ws : **Event: onQuestionRevealed**\n(RATING-Frage)
ws -> view : //QuestionStudentDTO//\n{ type: "RATING",\nratingMin: 1, ratingMax: 5,\nratingLabelMin: "Schlecht",\nratingLabelMax: "Super" }
view -> student : Skala anzeigen:\nSchlecht â‘  â‘¡ â‘¢ â‘£ â‘¤ Super

student -> view : "â‘£" antippen
view -> http : **vote.submit()**\n{ ratingValue: 4 }
http -> router : HTTP POST /trpc
router --> http : { success: true }

== Phase 4: Ergebnis empfangen ==

wss -> ws : **Event: onResultsRevealed**\n//QuestionRevealedDTO//
note over dto
  âœ… **Jetzt mit isCorrect!**
  Erst nach expliziter AuflÃ¶sung
  durch den Dozenten (Status=RESULTS)
end note

ws -> view : //QuestionRevealedDTO//\n{ answers: [\n  { id: "a1", text: "10",\n    isCorrect: false, voteCount: 2 },\n  { id: "a2", text: "12",\n    **isCorrect: true**, voteCount: 15 },\n  ... ] }

view -> student : Eigene Antwort markiert:\nâ—‹ B: 12 âœ… Richtig! (grÃ¼n)

== Phase 5: PersÃ¶nliche Scorecard ==

wss -> ws : **Event: onPersonalResult**\n//PersonalScorecardDTO//
note over wss
  Individuell pro Participant!
  Kein Broadcast an alle.
end note

ws -> view : //PersonalScorecardDTO//\n{ wasCorrect: true,\nquestionScore: 2064,\nbaseScore: 1720,\nstreakCount: 3,\nstreakMultiplier: 1.2,\ncurrentRank: 2,\npreviousRank: 5,\nrankChange: 3,\ntotalScore: 5840 }

view -> view : Motivationsmeldung\ngenerieren (clientseitig)
note over view
  Kontext: Richtig + Streak â‰¥ 3
  â†’ "On fire! ğŸ”¥ 3er-Serie!"
  Kontext: rankChange = +3
  â†’ "3 PlÃ¤tze aufgestiegen! ğŸš€"
end note

view -> student : ğŸ“‹ **PersÃ¶nliche Scorecard**\n(Bottom-Sheet-Overlay):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ âœ… Richtig!          â”‚\nâ”‚ +2064 Punkte        â”‚\nâ”‚  (1720 Ã— 1.2 Streak)â”‚\nâ”‚ ğŸ”¥ 3er-Serie!       â”‚\nâ”‚ Rang: 2 (â†‘3 PlÃ¤tze) â”‚\nâ”‚ Gesamt: 5840 Pkte   â”‚\nâ”‚ "On fire! ğŸ”¥"       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

== Phase 6: Emoji-Reaktion ==

opt Emoji-Reaktionen aktiv
  view -> student : Emoji-Leiste:\nğŸ‘  ğŸ‰  ğŸ˜®  ğŸ˜‚  ğŸ˜¢
  student -> view : "ğŸ‰" antippen
  view -> http : **session.react()**\n//SendEmojiReactionInputSchema//\n{ sessionId, questionId,\nemoji: "ğŸ‰" }
  http -> router : HTTP POST /trpc
  router -> redis : PUBLISH emoji\n(flÃ¼chtig, nicht persistiert)
  router --> http : ok
end

== Phase 7: NÃ¤chste Frage ==

wss -> ws : **Event: onStatusChanged**\n{ status: "ACTIVE" }
ws -> view : Scorecard ausblenden\nNeue Frage ladenâ€¦

wss -> ws : **Event: onQuestionRevealed**\n//QuestionStudentDTO// (nÃ¤chste Frage)
note over view : Schleife wiederholt sich

== Phase 8: Session beendet ==

wss -> ws : **Event: onStatusChanged**\n{ status: "FINISHED" }
ws -> view : Session-Ende

view -> http : **session.getLeaderboard()**\n{ sessionId }
http -> router : HTTP GET /trpc
router --> http : //LeaderboardEntryDTO[]//

view -> student : ğŸ† Finales Ranking:\n#1 Albert Einstein â€“ 7200\n#2 **Marie Curie â€“ 5840** â† Du\n#3 Ada Lovelace â€“ 5100

wss -> ws : Verbindung geschlossen

== Sonderpfad: Q&A-Modus (Epic 8) ==

student -> view : Q&A-Session beitreten

view -> ws : **Subscribe:**\nqa.onQuestionsUpdated
ws -> wss : WebSocket CONNECT

student -> view : Frage eingeben:\n"Kommt das in der Klausur?"
view -> http : **qa.submit()**\n//SubmitQaQuestionInputSchema//\n{ sessionId,\ntext: "Kommt das in der Klausur?" }
http -> router : HTTP POST /trpc
router -> pg : QaQuestion INSERT\n(participantId fÃ¼r 3-Fragen-Limit)
router -> wss : Push Update
router --> http : { questionId }

wss -> ws : **Event: onQuestionsUpdated**\n//QaQuestionDTO[]//\n[{ text, upvoteCount: 0,\nstatus: "ACTIVE",\nhasUpvoted: false }]
ws -> view : Fragenliste aktualisieren

student -> view : Frage upvoten ğŸ‘
view -> http : **qa.upvote()**\n//UpvoteQaQuestionInputSchema//\n{ questionId }
http -> router : HTTP POST /trpc
router -> pg : QaUpvote INSERT\n@@unique(qaQuestionId, participantId)
router -> pg : QaQuestion UPDATE\nupvoteCount++
router -> wss : Push Update

alt Toggle: bereits gevotet
  student -> view : Erneut antippen (Upvote entfernen)
  view -> http : **qa.upvote()** (Toggle)
  http -> router : HTTP POST /trpc
  router -> pg : QaUpvote DELETE\nupvoteCount--
end

wss -> ws : **Event: onQuestionsUpdated**\n(sortiert nach Upvotes, Echtzeit)

== Verbindungsabbruch & Reconnect (Story 4.3) ==

ws ->x wss : âš¡ Verbindung unterbrochen
view -> student : âš ï¸ "Verbindung\nunterbrochenâ€¦"
view -> ws : Reconnect-Versuch\n(Exponential Backoff:\n1s â†’ 2s â†’ 4s â†’ 8s)
ws -> wss : WebSocket RECONNECT
wss -> ws : Aktuellen Session-State\nsynchronisieren
view -> student : âœ… "Wieder verbunden!"

@enduml
